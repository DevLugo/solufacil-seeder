import { PrismaClient } from '@prisma/client';
import { cleanUpDb } from './utils';
import { seedLoans } from './loan';
import { seedExpenses } from './expenses';
import { seedAccounts } from './account';
import { seedLeads, extractLeadsData } from './leads';
import { getYearResume } from './report/month';
import { seedNomina } from './nomina';
import * as readline from 'readline';

export const prisma = new PrismaClient();

// Funci√≥n para leer input del usuario
function askQuestion(question: string): Promise<string> {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    return new Promise((resolve) => {
        rl.question(question, (answer) => {
            rl.close();
            resolve(answer);
        });
    });
}

async function getOrCreateConnectAccount() {
    const existingConnectAccount = await prisma.account.findFirst({
        where: {
            type: 'TRAVEL_EXPENSES'
            // No se especifica route, por lo que se busca una cuenta sin ruta asociada
        }
    });

    if (existingConnectAccount) {
        console.log('‚úÖ Cuenta de gastos de viaje encontrada y reutilizada:', existingConnectAccount.name);
        return existingConnectAccount;
    }
    
    const newConnectAccount = await prisma.account.create({
        data: {
            name: 'Cuenta de gastos de viaje',
            type: 'TRAVEL_EXPENSES',
            amount: "0"
            // No se especifica routes, por lo que no se asocia a ninguna ruta
        }
    });

    console.log('‚úÖ Nueva cuenta de gastos de viaje creada:', newConnectAccount.name);
    return newConnectAccount;
}

async function getOrCreateTokaAccount() {
    const existingTokaAccount = await prisma.account.findFirst({
        where: {
            type: 'PREPAID_GAS'
            // No se especifica route, por lo que se busca una cuenta sin ruta asociada
        }
    });

    if (existingTokaAccount) {
        console.log('‚úÖ Cuenta de gasolina encontrada y reutilizada:', existingTokaAccount.name);
        return existingTokaAccount;
    }
    
    const newTokaAccount = await prisma.account.create({
        data: {
            name: 'Cuenta de gasolina',
            type: 'PREPAID_GAS',
            amount: "0"
            // No se especifica routes, por lo que no se asocia a ninguna ruta
        }
    });

    console.log('‚úÖ Nueva cuenta de gasolina creada:', newTokaAccount.name);
    return newTokaAccount;
}

// Funci√≥n para obtener o crear la cuenta bancaria compartida
async function getOrCreateSharedBankAccount() {
    // Buscar si ya existe una cuenta bancaria compartida
    const existingBankAccount = await prisma.account.findFirst({
        where: {
            type: 'BANK'
            // No se especifica route, por lo que se busca una cuenta sin ruta asociada
        }
    });

    if (existingBankAccount) {
        console.log('‚úÖ Cuenta bancaria compartida encontrada y reutilizada:', existingBankAccount.name);
        return existingBankAccount;
    }

    // Si no existe, crear una nueva cuenta bancaria compartida
    const newBankAccount = await prisma.account.create({
        data: {
            name: 'Cuenta Bancaria Compartida',
            type: 'BANK',
            amount: "0"
            // No se especifica routes, por lo que no se asocia a ninguna ruta
        }
    });

    console.log('‚úÖ Nueva cuenta bancaria compartida creada:', newBankAccount.name);
    return newBankAccount;
}

// Funci√≥n para obtener o crear la cuenta de caja de oficina
async function getOrCreateOfficeCashAccount() {
    // Buscar si ya existe una cuenta de caja de oficina
    const existingOfficeAccount = await prisma.account.findFirst({
        where: {
            type: 'OFFICE_CASH_FUND'
            // No se especifica route, por lo que se busca una cuenta sin ruta asociada
        }
    });

    if (existingOfficeAccount) {
        console.log('‚úÖ Cuenta de caja de oficina encontrada y reutilizada:', existingOfficeAccount.name);
        return existingOfficeAccount;
    }

    // Si no existe, crear una nueva cuenta de caja de oficina
    const newOfficeAccount = await prisma.account.create({
        data: {
            name: 'Caja Merida',
            type: 'OFFICE_CASH_FUND',
            amount: "0"
            // No se especifica routes, por lo que no se asocia a ninguna ruta
        }
    });

    console.log('‚úÖ Nueva cuenta de caja de oficina creada:', newOfficeAccount.name);
    return newOfficeAccount;
}

// Funci√≥n para obtener los datos de snapshot de la ruta
async function getRouteSnapshotData(routeId: string) {
    const route = await prisma.route.findUnique({
        where: { id: routeId },
        include: {
            localities: true,
            employees: {
                include: {
                    personalData: true
                }
            }
        }
    });

    if (!route) {
        throw new Error(`Ruta con ID ${routeId} no encontrada`);
    }

    // Obtener la primera localidad asociada a la ruta (si existe)
    const location = route.localities[0];
    
    // Obtener el primer empleado/lead asociado a la ruta (si existe)
    const lead = route.employees[0];

    return {
        routeId: route.id,
        routeName: route.name,
        locationId: location?.id || '',
        locationName: location?.name || '',
        leadId: lead?.id || '',
        leadName: lead?.personalData?.fullName || '',
        leadAssignedAt: new Date() // Usar la fecha actual como fecha de asignaci√≥n
    };
}

// Funci√≥n para crear mapeo de oldId a realId usando el Excel
async function createLeadMapping(routeId: string, excelFileName: string, routeName: string) {
    // Extraer datos del Excel
    const leadsData = extractLeadsData(excelFileName, routeName);
    console.log(`üìä Total de leads extra√≠dos del Excel: ${leadsData.length}`);
    console.log(`üìã Primeros 5 leads del Excel:`, leadsData.slice(0, 5).map(l => ({ oldId: l.oldId, nombre: l.nombre, apellidos: l.apellidos })));
    
    // Obtener todos los empleados de la ruta
    const employees = await prisma.employee.findMany({
        where: { routesId: routeId },
        include: { personalData: true }
    });
    console.log(`üë• Total de empleados en la ruta: ${employees.length}`);
    console.log(`üìã Primeros 5 empleados:`, employees.slice(0, 5).map(e => ({ id: e.id, oldId: e.oldId, fullName: e.personalData?.fullName })));
    
    // Crear mapeo de oldId a realId
    const leadMapping: { [oldId: string]: string } = {};
    
    for (const excelLead of leadsData) {
        const oldId = excelLead.oldId;
        
        // Buscar el empleado correspondiente en la base de datos
        const employee = employees.find(emp => 
            emp.oldId === oldId || 
            emp.personalData?.fullName === `${excelLead.nombre} ${excelLead.apellidos}`
        );
        
        if (employee) {
            leadMapping[oldId] = employee.id;
            console.log(`‚úÖ Mapeo creado: ${oldId} -> ${employee.id} (${employee.personalData?.fullName})`);
        } else {
            console.log(`‚ö†Ô∏è No se encontr√≥ empleado para: ${excelLead.nombre} ${excelLead.apellidos} con oldId: ${oldId}`);
        }
    }
    
    console.log(`üìä Total de mapeos creados: ${Object.keys(leadMapping).length}`);
    console.log(`üìã Claves del mapeo:`, Object.keys(leadMapping));
    
    return leadMapping;
}

// Funci√≥n para portafolio cleanup
async function portfolioCleanup(cashAccountId: string, bankAccountId: string, routeId: string) {
    const startDate = new Date('2020-01-01');
    const endDate = new Date('2024-03-31');
    const applicationDate = new Date('2025-04-01');
    
    try {
        // 1. Obtener pr√©stamos del per√≠odo especificado
        console.log('üîç Obteniendo pr√©stamos del per√≠odo...');
        const periodLoans = await prisma.loan.findMany({
            where: {
                signDate: {
                    gte: startDate,
                    lte: endDate
                },
                snapshotRouteId: routeId
            },
            include: {
                borrower: {
                    include: {
                        personalData: true
                    }
                },
                payments: {
                    include: {
                        transactions: true
                    }
                }
            },
            orderBy: {
                signDate: 'asc'
            }
        });
        
        console.log(`üìä Total de pr√©stamos en el per√≠odo: ${periodLoans.length}`);
        
        // 2. Procesar y agregar informaci√≥n de los pr√©stamos
        console.log('üìä Procesando informaci√≥n de pr√©stamos...');
        let totalAmountGived = 0;
        let totalRequestedAmount = 0;
        let totalProfitAmount = 0;
        let activeLoans = 0;
        let finishedLoans = 0;
        
        for (const loan of periodLoans) {
            // Calcular totales
            totalAmountGived += Number(loan.amountGived || 0);
            totalRequestedAmount += Number(loan.requestedAmount || 0);
            totalProfitAmount += Number(loan.profitAmount || 0);
            
            // Contar por estado
            if (loan.status === 'ACTIVE') {
                activeLoans++;
            } else if (loan.status === 'FINISHED') {
                finishedLoans++;
            }
            
            console.log(`üìã Pr√©stamo: ${loan.oldId} - ${loan.borrower?.personalData?.fullName || 'Sin nombre'} - $${loan.amountGived} - ${loan.status}`);
        }
        
        // 3. Crear registro en la tabla portfolioCleanup
        console.log('üìù Creando registro en tabla portfolioCleanup...');
        await prisma.portfolioCleanup.create({
            data: {
                name: `Portfolio Cleanup - ${startDate.toISOString().split('T')[0]} a ${endDate.toISOString().split('T')[0]}`,
                description: `An√°lisis de ${periodLoans.length} pr√©stamos del per√≠odo hist√≥rico. Activos: ${activeLoans}, Terminados: ${finishedLoans}. Monto total: $${totalAmountGived.toFixed(2)}`,
                cleanupDate: applicationDate,
                fromDate: startDate,
                toDate: endDate,
                excludedLoansCount: periodLoans.length,
                excludedAmount: totalAmountGived,
                routeId: routeId
            }
        });
        
    } catch (error) {
        console.error('‚ùå Error durante el portafolio cleanup:', error);
        throw error;
    }
}

// Funci√≥n para procesar una ruta espec√≠fica
async function processRoute(routeName?: string) {
    // Si no se proporciona el nombre de la ruta, preguntarlo
    if (!routeName) {
        routeName = await askQuestion('¬øCu√°l es el nombre de la ruta? (ej: Ruta 2, Ruta 3, etc.): ');
        
        if (!routeName.trim()) {
            console.error('‚ùå El nombre de la ruta no puede estar vac√≠o');
            return;
        }
    }

    // Generar autom√°ticamente el nombre del archivo Excel bas√°ndose en el nombre de la ruta
    const excelFileName = `${routeName.toLowerCase().replace(/\s+/g, '')}.xlsm`;

    console.log(`üöÄ Iniciando proceso para la ruta: ${routeName}`);
    console.log(`üìä Usando archivo Excel: ${excelFileName}`);

    // Obtener o crear las cuentas compartidas (solo si no existen o si se resete√≥ la DB)
    const sharedBankAccount = await getOrCreateSharedBankAccount();
    const tokaAccount = await getOrCreateTokaAccount();
    const connectAccount = await getOrCreateConnectAccount();
    const officeCashAccount = await getOrCreateOfficeCashAccount();
    console.log('====CONNECT ACCOUNT====', connectAccount);
    console.log('====TOKA ACCOUNT====', tokaAccount);
    console.log('====OFFICE CASH ACCOUNT====', officeCashAccount);

    // Crear la ruta y su cuenta de efectivo espec√≠fica
    const routeWithCashAccount = await prisma.route.create({
        data: {
            name: routeName,
            accounts: {
                create: {
                    name: `${routeName} Caja`,
                    type: 'EMPLOYEE_CASH_FUND',
                    amount: "0",
                }
            }
        },
        include: {
            accounts: true,
        }
    });

    // Conectar la ruta a todas las cuentas compartidas existentes
    await prisma.route.update({
        where: { id: routeWithCashAccount.id },
        data: {
            accounts: {
                connect: [
                    { id: sharedBankAccount.id },
                    { id: tokaAccount.id },
                    { id: connectAccount.id },
                    { id: officeCashAccount.id }
                ]
            }
        }
    });

    console.log(`‚úÖ Ruta "${routeName}" creada con cuenta de efectivo`);
    console.log(`üîó Ruta conectada a cuentas compartidas:`);
    console.log(`   - Cuenta Bancaria: ${sharedBankAccount.name}`);
    console.log(`   - Cuenta Gasolina: ${tokaAccount.name}`);
    console.log(`   - Cuenta Gastos: ${connectAccount.name}`);
    console.log(`   - Caja Merida: ${officeCashAccount.name}`);
    const routeId = routeWithCashAccount.id;
    if (routeWithCashAccount.accounts?.[0]?.id) {
        const cashAccountId = routeWithCashAccount.accounts[0].id;
        const bankAccountId = sharedBankAccount.id;
        const tokaAccountId = tokaAccount.id;
        const connectAccountId = connectAccount.id;

        console.log(`üí∞ Cuenta de efectivo: ${cashAccountId}`);
        console.log(`üè¶ Cuenta bancaria compartida: ${bankAccountId}`);

        // Obtener los datos de snapshot de la ruta
        const snapshotData = await getRouteSnapshotData(routeWithCashAccount.id);

        await seedLeads(routeWithCashAccount.id, routeName, excelFileName);
        
        // Crear mapeo de leads usando el Excel
        const leadMapping = await createLeadMapping(routeWithCashAccount.id, excelFileName, routeName);
        
        console.log('üîÑ ========== INICIANDO SEED EXPENSES ==========');
        await seedExpenses(cashAccountId, bankAccountId, tokaAccountId, connectAccountId, snapshotData, excelFileName,routeId, leadMapping);
        console.log('‚úÖ SEED EXPENSES COMPLETADO');
        
        console.log('üîÑ ========== INICIANDO SEED LOANS ==========');
        await seedLoans(cashAccountId, bankAccountId, snapshotData, excelFileName, leadMapping);
        console.log('‚úÖ SEED LOANS COMPLETADO');
        
        console.log('üîÑ ========== INICIANDO SEED NOMINA ==========');
        await seedNomina(bankAccountId, snapshotData, excelFileName, routeId, leadMapping);
        console.log('‚úÖ SEED NOMINA COMPLETADO');
        
        console.log('üîÑ ========== INICIANDO PORTFOLIO CLEANUP ==========');
        await portfolioCleanup(cashAccountId, bankAccountId, routeId);
        console.log('‚úÖ PORTFOLIO CLEANUP COMPLETADO');

        //
        //await seedPayments(route2.id);
        //TODO: save comision and earned amount on payments
        console.log('‚úÖ Datos guardados en la base de datos');

        const yearResume = await getYearResume(
            cashAccountId,
            bankAccountId,
            2025
        );
        
        console.table(yearResume);
        //console.table(monthResume);
        let totalAnnualBalance = 0;
        let totalAnnualBalanceWithReinvest = 0;

        for (const month of Object.keys(yearResume)) {
            totalAnnualBalance += yearResume[month].balance || 0;
            totalAnnualBalanceWithReinvest += yearResume[month].balanceWithReinvest || 0;
        }

        console.log('Total Annual Balance 2024:', totalAnnualBalance);
        console.log('Total Annual Balance with Reinvest 2024:', totalAnnualBalanceWithReinvest);

        const yearResume2023 = await getYearResume(
            cashAccountId,
            bankAccountId,
            2023
        );
        console.table(yearResume2023);
        let totalAnnualBalance23 = 0;
        let totalAnnualBalanceWithReinvest23 = 0;
        for (const month of Object.keys(yearResume2023)) {
            totalAnnualBalance23 += yearResume2023[month].balance || 0;
            totalAnnualBalanceWithReinvest23 += yearResume2023[month].balanceWithReinvest || 0;
        }

        console.log('Total Annual Balance 2023:', totalAnnualBalance23);
        console.log('Total Annual Balance with Reinvest 2023:', totalAnnualBalanceWithReinvest23);

        console.log('‚úÖ Proceso completado para la ruta:', routeName);
        
        // Preguntar si quiere procesar otra ruta
        const anotherRoute = await askQuestion('¬øQuieres procesar otra ruta? (s/n): ');
        const shouldProcessAnother = anotherRoute.toLowerCase() === 's' || anotherRoute.toLowerCase() === 'si' || anotherRoute.toLowerCase() === 'y' || anotherRoute.toLowerCase() === 'yes';
        
        if (shouldProcessAnother) {
            console.log('\nüîÑ ========== PROCESANDO NUEVA RUTA ==========\n');
            return await processRoute(); // Llamada recursiva para procesar otra ruta (sin par√°metro)
        } else {
            console.log('üèÅ Proceso finalizado. ¬°Hasta luego!');
            return yearResume;
        }
    } else {
        console.error('‚ùå Error: No se pudo crear la cuenta de efectivo para la ruta');
    }
}

async function main() {
    try {
        // Preguntar al usuario si quiere reiniciar la base de datos
        const resetDb = await askQuestion('¬øQuieres reiniciar la base de datos? (s/n): ');
        const shouldResetDb = resetDb.toLowerCase() === 's' || resetDb.toLowerCase() === 'si' || resetDb.toLowerCase() === 'y' || resetDb.toLowerCase() === 'yes';
        
        if (shouldResetDb) {
            console.log('üîÑ Reiniciando base de datos...');
            await cleanUpDb();
            await seedAccounts();
            console.log('‚úÖ Base de datos reiniciada');
        } else {
            console.log('‚è≠Ô∏è Continuando con la base de datos existente...');
        }

        // Preguntar al usuario cu√°l es la ruta
        const routeName = await askQuestion('¬øCu√°l es el nombre de la ruta? (ej: Ruta 2, Ruta 3, etc.): ');
        
        if (!routeName.trim()) {
            console.error('‚ùå El nombre de la ruta no puede estar vac√≠o');
            return;
        }

        // Generar autom√°ticamente el nombre del archivo Excel bas√°ndose en el nombre de la ruta
        const excelFileName = `${routeName.toLowerCase().replace(/\s+/g, '')}.xlsm`;

        console.log(`üöÄ Iniciando proceso para la ruta: ${routeName}`);
        console.log(`üìä Usando archivo Excel: ${excelFileName}`);

        // Iniciar el procesamiento de rutas
        await processRoute(routeName);
        
    } catch (error) {
        console.error('‚ùå Error durante la ejecuci√≥n:', error);
    }
}

main()
    .catch(e => {
        console.error('‚ùå Error en main():', e);
    })
    .finally(async () => {
        console.log('üîå ========== CERRANDO CONEXI√ìN PRISMA ==========');
        console.log('üîå Ejecutando prisma.$disconnect()...');
        await prisma.$disconnect();
        console.log('üîå Conexi√≥n Prisma cerrada');
    });